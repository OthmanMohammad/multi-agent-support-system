"""
Vulnerability Scanner Agent - TASK-2305

Weekly vulnerability scanning for dependencies, code, and infrastructure.
Integrates with CVE databases and security advisories.
"""

from typing import Dict, Any, List, Optional, Set
from datetime import datetime, timedelta
import re

from src.workflow.state import AgentState
from src.agents.base import BaseAgent, AgentConfig, AgentType, AgentCapability
from src.utils.logging.setup import get_logger
from src.services.infrastructure.agent_registry import AgentRegistry


@AgentRegistry.register("vulnerability_scanner", tier="operational", category="security")
class VulnerabilityScannerAgent(BaseAgent):
    """
    Vulnerability Scanner Agent.

    Comprehensive vulnerability scanning:
    - Dependency vulnerability scanning (CVE database)
    - Code security analysis (SAST)
    - Infrastructure misconfiguration detection
    - Container security scanning
    - API security testing
    - Third-party library vulnerabilities
    - Known exploit detection
    - Patch availability checking

    Severity Levels:
    - Critical (CVSS 9.0-10.0): Immediate action required
    - High (CVSS 7.0-8.9): Fix within 7 days
    - Medium (CVSS 4.0-6.9): Fix within 30 days
    - Low (CVSS 0.1-3.9): Fix within 90 days
    """

    # CVSS (Common Vulnerability Scoring System) severity ranges
    CVSS_SEVERITY = {
        "critical": (9.0, 10.0),
        "high": (7.0, 8.9),
        "medium": (4.0, 6.9),
        "low": (0.1, 3.9),
        "none": (0.0, 0.0)
    }

    # Vulnerability categories
    VULNERABILITY_CATEGORIES = [
        "dependency",
        "code_injection",
        "authentication",
        "authorization",
        "crypto",
        "xss",
        "sql_injection",
        "csrf",
        "ssrf",
        "path_traversal",
        "xxe",
        "deserialization",
        "misconfiguration"
    ]

    # SLA for remediation
    REMEDIATION_SLA = {
        "critical": timedelta(days=1),
        "high": timedelta(days=7),
        "medium": timedelta(days=30),
        "low": timedelta(days=90)
    }

    def __init__(self):
        config = AgentConfig(
            name="vulnerability_scanner",
            type=AgentType.SECURITY,
            model="claude-sonnet-4-5-20250929",
            temperature=0.1,
            max_tokens=3000,
            capabilities=[AgentCapability.DATABASE_READ, AgentCapability.DATABASE_WRITE],
            tier="operational"
        )
        super().__init__(config)
        self.logger = get_logger(__name__)

    async def process(self, state: AgentState) -> AgentState:
        """
        Perform vulnerability scan.

        Args:
            state: Current agent state with scan targets

        Returns:
            Updated state with vulnerability scan results
        """
        self.logger.info("vulnerability_scan_started")

        state = self.update_state(state)

        # Extract parameters
        scan_type = state.get("entities", {}).get("scan_type", "comprehensive")
        dependencies = state.get("entities", {}).get("dependencies", [])
        code_base = state.get("entities", {}).get("code_base", {})
        infrastructure = state.get("entities", {}).get("infrastructure", {})
        containers = state.get("entities", {}).get("containers", [])

        self.logger.debug(
            "vulnerability_scan_details",
            scan_type=scan_type,
            dependencies_count=len(dependencies),
            containers_count=len(containers)
        )

        # Scan dependencies
        dependency_vulns = self._scan_dependencies(dependencies)

        # Scan code
        code_vulns = self._scan_code(code_base)

        # Scan infrastructure
        infra_vulns = self._scan_infrastructure(infrastructure)

        # Scan containers
        container_vulns = self._scan_containers(containers)

        # Combine all vulnerabilities
        all_vulnerabilities = self._combine_vulnerabilities(
            dependency_vulns,
            code_vulns,
            infra_vulns,
            container_vulns
        )

        # Prioritize vulnerabilities
        prioritized_vulns = self._prioritize_vulnerabilities(all_vulnerabilities)

        # Calculate risk score
        risk_score = self._calculate_risk_score(all_vulnerabilities)

        # Generate remediation plan
        remediation_plan = self._generate_remediation_plan(prioritized_vulns)

        # Check for active exploits
        active_exploits = self._check_active_exploits(all_vulnerabilities)

        # Generate recommendations
        recommendations = self._generate_recommendations(
            all_vulnerabilities,
            active_exploits,
            remediation_plan
        )

        # Format response
        response = self._format_vulnerability_report(
            scan_type,
            all_vulnerabilities,
            prioritized_vulns,
            risk_score,
            remediation_plan,
            active_exploits,
            recommendations
        )

        state["agent_response"] = response
        state["vulnerabilities"] = all_vulnerabilities
        state["prioritized_vulnerabilities"] = prioritized_vulns
        state["vulnerability_risk_score"] = risk_score
        state["remediation_plan"] = remediation_plan
        state["active_exploits"] = active_exploits
        state["recommendations"] = recommendations
        state["response_confidence"] = 0.93
        state["status"] = "resolved"
        state["next_agent"] = None

        # Alert on critical vulnerabilities
        critical_vulns = [v for v in all_vulnerabilities if v["severity"] == "critical"]
        if critical_vulns or active_exploits:
            state["alert_pagerduty"] = True
            state["alert_severity"] = "critical"
            state["alert_message"] = f"CRITICAL: {len(critical_vulns)} critical vulnerabilities found"

        self.logger.info(
            "vulnerability_scan_completed",
            total_vulnerabilities=len(all_vulnerabilities),
            critical_count=len(critical_vulns),
            active_exploits=len(active_exploits),
            risk_score=risk_score
        )

        return state

    def _scan_dependencies(self, dependencies: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan dependencies for known vulnerabilities.

        Args:
            dependencies: List of dependencies with versions

        Returns:
            List of dependency vulnerabilities
        """
        vulnerabilities = []

        # Simulate CVE database lookup
        for dep in dependencies:
            name = dep.get("name", "")
            version = dep.get("version", "")

            # Simulate vulnerability detection
            # In production, query actual CVE databases (NVD, Snyk, etc.)
            if self._has_known_vulnerability(name, version):
                vuln = {
                    "vulnerability_id": f"CVE-2024-{hash(name + version) % 10000:05d}",
                    "type": "dependency",
                    "category": "dependency",
                    "package": name,
                    "version": version,
                    "cvss_score": self._calculate_mock_cvss(name, version),
                    "severity": None,  # Will be set based on CVSS
                    "description": f"Known vulnerability in {name} version {version}",
                    "affected_versions": f"< {version}",
                    "fixed_version": self._get_fixed_version(version),
                    "exploit_available": self._check_exploit_availability(name),
                    "discovered_at": datetime.utcnow().isoformat()
                }

                # Set severity based on CVSS score
                vuln["severity"] = self._cvss_to_severity(vuln["cvss_score"])

                vulnerabilities.append(vuln)

        return vulnerabilities

    def _scan_code(self, code_base: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Scan code for security vulnerabilities (SAST).

        Args:
            code_base: Code base to scan

        Returns:
            List of code vulnerabilities
        """
        vulnerabilities = []

        # Simulate static analysis
        # In production, use tools like Semgrep, Bandit, SonarQube

        # Check for common patterns
        code_patterns = {
            "sql_injection": r"execute\(.*\+.*\)",
            "xss": r"innerHTML\s*=",
            "hardcoded_secrets": r"(password|api_key|secret)\s*=\s*['\"][^'\"]+['\"]",
            "weak_crypto": r"md5|sha1",
        }

        for category, pattern in code_patterns.items():
            # Simulate finding vulnerabilities
            if code_base.get("has_" + category, False):
                vuln = {
                    "vulnerability_id": f"CODE-{category.upper()}-{hash(category) % 1000:03d}",
                    "type": "code",
                    "category": category,
                    "cvss_score": 6.5,
                    "severity": "medium",
                    "description": f"Potential {category.replace('_', ' ')} vulnerability detected",
                    "location": f"src/module/{category}.py:123",
                    "remediation": self._get_code_remediation(category),
                    "discovered_at": datetime.utcnow().isoformat()
                }
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _scan_infrastructure(self, infrastructure: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Scan infrastructure for misconfigurations.

        Args:
            infrastructure: Infrastructure configuration

        Returns:
            List of infrastructure vulnerabilities
        """
        vulnerabilities = []

        # Check common misconfigurations
        checks = {
            "open_ports": "Unnecessary open ports detected",
            "weak_ssl": "Weak SSL/TLS configuration",
            "missing_firewall": "Firewall not properly configured",
            "public_s3_buckets": "S3 buckets publicly accessible",
            "unencrypted_storage": "Storage not encrypted at rest"
        }

        for check, description in checks.items():
            if infrastructure.get(check, False):
                vuln = {
                    "vulnerability_id": f"INFRA-{check.upper()}-001",
                    "type": "infrastructure",
                    "category": "misconfiguration",
                    "cvss_score": 7.5,
                    "severity": "high",
                    "description": description,
                    "remediation": self._get_infra_remediation(check),
                    "discovered_at": datetime.utcnow().isoformat()
                }
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _scan_containers(self, containers: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Scan containers for vulnerabilities.

        Args:
            containers: List of containers

        Returns:
            List of container vulnerabilities
        """
        vulnerabilities = []

        for container in containers:
            image = container.get("image", "")
            tag = container.get("tag", "latest")

            # Check for known vulnerabilities in base images
            if self._has_container_vulnerability(image, tag):
                vuln = {
                    "vulnerability_id": f"CONTAINER-{hash(image + tag) % 1000:03d}",
                    "type": "container",
                    "category": "dependency",
                    "image": image,
                    "tag": tag,
                    "cvss_score": 8.0,
                    "severity": "high",
                    "description": f"Vulnerabilities in container image {image}:{tag}",
                    "remediation": f"Update to latest secure base image",
                    "discovered_at": datetime.utcnow().isoformat()
                }
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _has_known_vulnerability(self, name: str, version: str) -> bool:
        """Check if dependency has known vulnerability (mock)."""
        # Simulate vulnerability detection
        # In production, query CVE databases
        vulnerable_packages = ["lodash", "axios", "express", "react", "django"]
        return any(pkg in name.lower() for pkg in vulnerable_packages)

    def _calculate_mock_cvss(self, name: str, version: str) -> float:
        """Calculate mock CVSS score."""
        # Simulate CVSS scoring
        base_score = 5.0 + (hash(name + version) % 50) / 10
        return round(min(base_score, 10.0), 1)

    def _get_fixed_version(self, current_version: str) -> str:
        """Get fixed version (mock)."""
        # Simulate version increment
        try:
            major, minor, patch = current_version.split('.')
            patch = str(int(patch) + 1)
            return f"{major}.{minor}.{patch}"
        except:
            return "latest"

    def _check_exploit_availability(self, name: str) -> bool:
        """Check if public exploit exists (mock)."""
        # Simulate exploit database check
        return hash(name) % 3 == 0  # 33% chance of exploit

    def _has_container_vulnerability(self, image: str, tag: str) -> bool:
        """Check container vulnerability (mock)."""
        # Old tags more likely to have vulnerabilities
        old_tags = ["latest", "1.0", "alpine"]
        return tag in old_tags

    def _cvss_to_severity(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level."""
        for severity, (min_score, max_score) in self.CVSS_SEVERITY.items():
            if min_score <= cvss_score <= max_score:
                return severity
        return "low"

    def _get_code_remediation(self, category: str) -> str:
        """Get remediation advice for code vulnerabilities."""
        remediations = {
            "sql_injection": "Use parameterized queries or ORM",
            "xss": "Sanitize user input and use Content Security Policy",
            "hardcoded_secrets": "Move secrets to environment variables or secrets manager",
            "weak_crypto": "Use SHA-256 or stronger cryptographic algorithms"
        }
        return remediations.get(category, "Review and fix security issue")

    def _get_infra_remediation(self, check: str) -> str:
        """Get remediation advice for infrastructure issues."""
        remediations = {
            "open_ports": "Close unnecessary ports and use security groups",
            "weak_ssl": "Update to TLS 1.2+ with strong cipher suites",
            "missing_firewall": "Configure WAF and network firewall rules",
            "public_s3_buckets": "Set S3 buckets to private and use bucket policies",
            "unencrypted_storage": "Enable encryption at rest for all storage"
        }
        return remediations.get(check, "Fix infrastructure misconfiguration")

    def _combine_vulnerabilities(
        self,
        dependency_vulns: List[Dict[str, Any]],
        code_vulns: List[Dict[str, Any]],
        infra_vulns: List[Dict[str, Any]],
        container_vulns: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Combine all vulnerabilities."""
        return dependency_vulns + code_vulns + infra_vulns + container_vulns

    def _prioritize_vulnerabilities(
        self,
        vulnerabilities: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Prioritize vulnerabilities by severity and exploitability."""
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}

        return sorted(
            vulnerabilities,
            key=lambda v: (
                severity_order.get(v.get("severity", "low"), 999),
                -v.get("cvss_score", 0),
                not v.get("exploit_available", False)
            )
        )

    def _calculate_risk_score(self, vulnerabilities: List[Dict[str, Any]]) -> float:
        """Calculate overall risk score (0-100)."""
        if not vulnerabilities:
            return 0.0

        # Weight vulnerabilities by severity
        severity_weights = {"critical": 10, "high": 5, "medium": 2, "low": 1}

        total_score = sum(
            severity_weights.get(v.get("severity", "low"), 1)
            for v in vulnerabilities
        )

        # Normalize to 0-100
        max_possible = len(vulnerabilities) * 10
        normalized = min((total_score / max_possible) * 100, 100)

        return round(normalized, 1)

    def _generate_remediation_plan(
        self,
        vulnerabilities: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Generate prioritized remediation plan."""
        plan = []

        for vuln in vulnerabilities:
            severity = vuln.get("severity", "low")
            sla = self.REMEDIATION_SLA.get(severity, timedelta(days=90))
            deadline = datetime.utcnow() + sla

            plan_item = {
                "vulnerability_id": vuln.get("vulnerability_id"),
                "severity": severity,
                "cvss_score": vuln.get("cvss_score"),
                "description": vuln.get("description"),
                "remediation": vuln.get("remediation", vuln.get("fixed_version", "Update dependency")),
                "sla_days": sla.days,
                "deadline": deadline.isoformat(),
                "priority": severity
            }
            plan.append(plan_item)

        return plan

    def _check_active_exploits(
        self,
        vulnerabilities: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Check for vulnerabilities with active exploits."""
        return [
            v for v in vulnerabilities
            if v.get("exploit_available", False) and v.get("severity") in ["critical", "high"]
        ]

    def _generate_recommendations(
        self,
        vulnerabilities: List[Dict[str, Any]],
        active_exploits: List[Dict[str, Any]],
        remediation_plan: List[Dict[str, Any]]
    ) -> List[str]:
        """Generate security recommendations."""
        recommendations = []

        if active_exploits:
            recommendations.append(
                f"CRITICAL: {len(active_exploits)} vulnerabilities with active exploits detected. "
                "Patch immediately."
            )

        critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
        if critical_vulns:
            recommendations.append(
                f"{len(critical_vulns)} critical vulnerabilities found. "
                "Remediate within 24 hours per SLA."
            )

        high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
        if high_vulns:
            recommendations.append(
                f"{len(high_vulns)} high severity vulnerabilities. "
                "Remediate within 7 days."
            )

        if vulnerabilities:
            recommendations.append(
                "Follow remediation plan prioritized by severity and exploitability."
            )
            recommendations.append(
                "Schedule weekly vulnerability scans to catch new issues early."
            )

        if not vulnerabilities:
            recommendations.append(
                "No vulnerabilities detected. Continue regular scanning."
            )

        return recommendations

    def _format_vulnerability_report(
        self,
        scan_type: str,
        vulnerabilities: List[Dict[str, Any]],
        prioritized_vulns: List[Dict[str, Any]],
        risk_score: float,
        remediation_plan: List[Dict[str, Any]],
        active_exploits: List[Dict[str, Any]],
        recommendations: List[str]
    ) -> str:
        """Format vulnerability scan report."""
        critical_count = len([v for v in vulnerabilities if v.get("severity") == "critical"])
        high_count = len([v for v in vulnerabilities if v.get("severity") == "high"])
        medium_count = len([v for v in vulnerabilities if v.get("severity") == "medium"])
        low_count = len([v for v in vulnerabilities if v.get("severity") == "low"])

        report = f"""**Vulnerability Scan Report**

**Scan Type:** {scan_type}
**Risk Score:** {risk_score}/100
**Total Vulnerabilities:** {len(vulnerabilities)}
**Active Exploits:** {len(active_exploits)}

**Severity Breakdown:**
- ðŸ”´ Critical (CVSS 9.0-10.0): {critical_count}
- âš ï¸ High (CVSS 7.0-8.9): {high_count}
- ðŸ“‹ Medium (CVSS 4.0-6.9): {medium_count}
- â„¹ï¸ Low (CVSS 0.1-3.9): {low_count}

"""

        # Top vulnerabilities
        if prioritized_vulns:
            report += f"**Top Vulnerabilities (by priority):**\n"
            for vuln in prioritized_vulns[:5]:
                severity_icon = "ðŸ”´" if vuln["severity"] == "critical" else "âš ï¸" if vuln["severity"] == "high" else "ðŸ“‹"
                exploit_flag = " [EXPLOIT AVAILABLE]" if vuln.get("exploit_available") else ""
                report += f"{severity_icon} **{vuln['vulnerability_id']}** (CVSS {vuln.get('cvss_score', 0)}){exploit_flag}\n"
                report += f"   {vuln['description']}\n"
                report += f"   Remediation: {vuln.get('remediation', 'See details')}\n\n"

            if len(prioritized_vulns) > 5:
                report += f"... and {len(prioritized_vulns) - 5} more vulnerabilities\n\n"

        # Remediation priorities
        if remediation_plan:
            report += f"**Immediate Actions Required:**\n"
            for item in remediation_plan[:3]:
                report += f"- [{item['severity'].upper()}] {item['description']}\n"
                report += f"  Deadline: {item['deadline'][:10]} ({item['sla_days']} days)\n"

        # Recommendations
        if recommendations:
            report += f"\n**Recommendations:**\n"
            for rec in recommendations:
                report += f"- {rec}\n"

        report += f"\n*Vulnerability scan completed at {datetime.utcnow().isoformat()}*"
        report += f"\n*Next scan: {(datetime.utcnow() + timedelta(days=7)).isoformat()[:10]}*"

        return report
